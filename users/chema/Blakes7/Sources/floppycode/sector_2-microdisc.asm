;
; This part of the code is a bit tricky: Basically the Atmos with Microdisc and the Telestrat despite using a similar boot 
; loading system are actually loading the boot sector at different addresses.
;
; Since the 6502 is not particularly well equiped to handle code that can be loaded at any address we had to find a trick.
; What we are doing is to make the code run at a particular address, and have a small module that makes sure that it is
; moved at the correct place wherever it was loaded in first place. That makes the code a lot easier to write :)
;
; Warning: This whole code CANNOT be more than 256 bytes (ie: the size of the sector)
;
; The bootloader will be placed in the screen area because we know that this is not going to be used by the operating system.
; By chosing an address in HIRES area, we also guarantee that it will not be visible on the screen (the Oric boots in TEXT).
;
#define FINAL_ADRESS	$9800			; First 256 bytes of the STD charset are invisible

#define TELESTRAT_ALIGN
#ifdef TELESTRAT_ALIGN
#define PROTECT(X)  .dsb (((X)&3)-((*+3)&3))&3,$ea
#else
#define PROTECT(X) 
#endif

; This is to use the code that checks if an error occurs while loading a sector,
; so that not all the bytes are tranferred. It checks for the Ready bit in the STATUS
; which would signal an END OF COMMAND if there is such an error, instead of 
; finishing when 256 bytes are read.
; This was suggested by Fabrice Frances
#define CHECK_PARTIAL_SECTOR_LOADING

#define OPCODE_RTS			$60

#define FDC_command_register		$0310
#define FDC_status_register		$0310
#define FDC_track_register		$0311
#define FDC_sector_register		$0312
#define FDC_data			$0313
#define FDC_flags			$0314
#define FDC_drq                 	$0318	

#define FDC_Flag_DiscSide       	%00010000

#define CMD_ReadSector			$80
#define CMD_Seek			$1F

#define wait_status_floppy 		30

#include "floppy_description.h"       ; This file is generated by the floppy builder

	.zero
	
	*=$00
	
retry_counter		.dsb 1	; Number of attempts at loading data (ie: not quite clear what happens when this fails...)
	

	.text

	;
	; These are the 23 header bytes that goes before the actual executable part of the bootsector
	;
	.byt $00,$00,$FF,$00,$D0,$9F,$D0,$9F,$02,$B9,$01,$00,$FF,$00,$00,$B9,$E4,$B9,$00,$00,$E6,$12,$00

	.text

	;
	; Here starts the actual executable part, maximum available size is 233 bytes (256-23)
	;

	;
	; Try to find the load address
	;
	sei               	; Disable interruptions

	lda #OPCODE_RTS
	sta $00          	; Write in $00 Page => take one less byte
	jsr $0000     		; JSR on the RTS immediately return.

	;
	; Compute the absolute address of where the code we want to copy begins,
	; and save it in zero page ($00 and $01)
	;	
_start_relocator_
	tsx               	; Get stack offset
	dex
	clc
	lda $0100,x     	; Get LOW adress byte
	adc #<(_end_relocator_-_start_relocator_+1)
	sta $00
	lda $0101,x     	; Get HIGH adress byte
	adc #>(_end_relocator_-_start_relocator_+1)
	sta $01

	; Now $00 and $01 contain the adress of LABEL
	; We can now copy the whole code to it's new
	; location
	ldy #0
copy_loop
	lda ($00),y  
	sta FINAL_ADRESS,y
	iny
	cpy _END_-_BEGIN_
	bne copy_loop
	
	jmp FINAL_ADRESS
_end_relocator_


;
; Here is some code compiled at a fixed adress in memory.
;

     *=FINAL_ADRESS

_BEGIN_
	;
	; Switch to HIRES
	;
	ldy #39 			; From $9900 to $c000 is 39 pages (9984 bytes)
	lda #0
loop_hires_outer	
	tax
loop_hires_inner
__auto_hires
	sta $9900,x
	inx
	bne loop_hires_inner
	inc __auto_hires+2
	dey
	bne loop_hires_outer

	lda #30				; Write hires switch
	sta $bfdf


	;
	; Read sector data
	; 
	ldy #4
	sty retry_counter
read_sectors_loop

readretryloop
/* CHEMA: This is not needed
	nop
	nop
	nop
*/	
	
read_one_sector
	;
	; Check if we are on the correct track already and if not
	; then send a SEEK command to the FDC to move the head to
	; the correct track.
	;
	ldx #FLOPPY_LOADER_TRACK
	PROTECT(FDC_track_register)
	cpx FDC_track_register
	beq track_ok
	
	; Write the track number in the FDC data register
	PROTECT(FDC_data)
	stx FDC_data

	/* CHEMA: This is not needed
wait_drive2
	lda FDC_drq 				; We are waiting for the drive maybe not useful if drive is ready after the eprom boot
	bmi wait_drive2
	*/
	
	;
	; Send a SEEK command (change track)
	;
	lda #CMD_Seek
	PROTECT(FDC_command_register)
	sta FDC_command_register
	; 
	; Command words should only be loaded in the Command Register when the Busy status bit is off (Status bit 0). The one exception is the Force Interrupt command. 
	; Whenever a command is being executed, the Busy status bit is set. 
	; When a command is completed, an interrupt is generated and the busy status bit is reset. 
	; The Status Register indicates whethter the completed command encountered an error or was fault free. For ease of discussion, commands are divided into four types (I, II, III, IV).
	
	/* CHEMA: I changed this:
	ldy #4
r_wait_completion
	dey
	bne r_wait_completion
r2_wait_completion
	lda FDC_status_register
	lsr
	bcs r2_wait_completion
	asl
	*/
	; Chema: According to the sheet you have to wait 24us before reading the status after a write to 
	; a command register.
	ldy #5	;2
r_wait_completion
	dey	;2
	bne r_wait_completion ;2+1
	; = 26 cycles
	PROTECT(FDC_status_register)
r2_wait_completion
	lda FDC_status_register
	lsr
	bcs r2_wait_completion
track_ok	

	; Chema: Here is the thing... the COLOR macro takes 14 cycles...
	; This one is much much longer if wait_status_floppy (30) is used...
	ldy #3
waitcommand
	dey	;2
	bne waitcommand;2+1
	; = 16 cycles

	; Write the sector number in the FDC sector register
__auto__sector_index
	lda #FLOPPY_LOADER_SECTOR
	PROTECT(FDC_sector_register)
	sta FDC_sector_register ;
	
	lda #%10000100 			; Force the system to use the Side 0 of the A: drive
	sta FDC_flags
			
	;
	; Send a READSECTOR command
	;
	lda #CMD_ReadSector
	PROTECT(FDC_command_register)
	sta FDC_command_register

	; CHEMA: This is not needed
/*	
	ldy #wait_status_floppy
waitcommand2
	nop 					; Not useful but for old Floppy drive maybe
	nop 					; Not useful but for old Floppy drive maybe
	dey	
	bne waitcommand2
*/	

#ifdef CHECK_PARTIAL_SECTOR_LOADING
	; Chema: this is only needed if checking for partial
	; loading of a sector
	ldy #4	
tempoloop 
	dey
	bne tempoloop 	
#endif
	;
	; Read the sector data
	;
	ldy #0
	
#ifndef CHECK_PARTIAL_SECTOR_LOADING	
fetch_bytes_from_FDC
	lda FDC_drq
	bmi fetch_bytes_from_FDC
	PROTECT(FDC_data)
	lda FDC_data
__auto_write_address
	sta FLOPPY_LOADER_ADDRESS,y

	iny
	bne fetch_bytes_from_FDC
	; Done loading the sector
	
	; Added a wait for the command to finish, as suggested by Fabrice
	PROTECT(FDC_status_register)
busyloop	
	lda FDC_status_register
	lsr
	bcs busyloop
#else
	; Added the code suggested by Fabrice to deal with
	; sectors which are loaded only partially
	PROTECT(FDC_status_register)
checkbusy	
	lda FDC_status_register
	lsr
	bcc end_of_command
waitdrq
	lda FDC_drq
	bmi checkbusy
	PROTECT(FDC_data)
	lda FDC_data
__auto_write_address
	sta FLOPPY_LOADER_ADDRESS,y
	iny
	jmp waitdrq
end_of_command	
	; Done loading the sector
#endif	
	;asl
	and #($7C>>1)	; CHEMA: this does not correctly check for errors, see loader.asm it should be (imho) and #$7c, not $1c
	beq sector_OK
	dec retry_counter
	bne readretryloop
	
sector_OK
	inc __auto__sector_index+1
	inc __auto_write_address+2
	dec sector_counter
	bne read_sectors_loop

	;
	; Data successfully loaded (we hope)
	;
	;sei
	lda #%10000001 			; Disable the FDC (Eprom select + FDC Interrupt request)
	sta FDC_flags
	
	ldx #0                      ; 0 = Microdisc initialisation code
	jmp FLOPPY_LOADER_ADDRESS


sector_counter		.byt (($FFFF-FLOPPY_LOADER_ADDRESS)+1)/256


_END_

