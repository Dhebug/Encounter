// hopefully faster HIRES scroll than memcpy
	.zero

//_HRLines					.dsb 1

	.text

_ScrollHiresUp1
	; init pointers
	lda #$a0
	sta _ScrollHiresUp1_l2+2
	sta _ScrollHiresUp1_l2+5
	lda #00
	sta _ScrollHiresUp1_l2+4
	lda #40
	sta _ScrollHiresUp1_l2+1
	;
	ldx #33
_ScrollHiresUp1_l1
	ldy #0
_ScrollHiresUp1_l2
	lda $a000+40,y
	sta $a000,y
	iny
	cpy #6*40
	bne _ScrollHiresUp1_l2

	; add to pointers
	clc
	lda #<(6*40)
	adc _ScrollHiresUp1_l2+1
	sta _ScrollHiresUp1_l2+1
	lda #>(6*40)
	adc _ScrollHiresUp1_l2+2
	sta _ScrollHiresUp1_l2+2

	clc
	lda #<(6*40)
	adc _ScrollHiresUp1_l2+4
	sta _ScrollHiresUp1_l2+4
	lda #>(6*40)
	adc _ScrollHiresUp1_l2+5
	sta _ScrollHiresUp1_l2+5

	dex
	bne _ScrollHiresUp1_l1

	; last line after 6 * 33
	ldy #0
_ScrollHiresUp1_l3
	lda $a000+198*40+40,y
	sta $a000+198*40,y
	iny
	cpy #1*40
	bne _ScrollHiresUp1_l3

	rts


// second attempt, faster but it shows the columns moving, and it's still slow
// cf. http://osdk.defence-force.org/index.php?page=articles&ref=ART12
_ScrollHiresUp2
	ldy #0
_ScrollHiresUp1_l1

// this section generated by:
// for n in $(seq 0 198); do echo -e "\tlda \$a000+$n*40+40,y\n\tsta \$a000+$n*40,y" ; done
// BEGIN 
// END 

	iny
	cpy #40
	beq _ScrollHiresUp1_out
	jmp _ScrollHiresUp1_l1
_ScrollHiresUp1_out

#endif

